# 포트와 유스케이스를 통한 동작 처리
## 유스케이스를 통한 소프트웨어 동작 표현
- 소프트웨어 시스템 : 어떤 목표를 달성하기 위해 함께 동작하는 "소프트웨어의 동작"들을 모아둔것
- 소프트웨어의 동작 : 혼자, 혹은 다른 소프트웨어 동작과 함께 가치 있는 "소프트웨어 목표"(사용자 혹은 다른 소프트웨어 시스템이 정의한)를 실현하기 위해 기여하는 의미있는 행동
- 소프트웨어 목표 : 관심있는 사용자나 시스템이 명시하는 요구사항과 밀접하게 연결되어 있다.


- 사용자나 시스템을 이해당사자(stakeholders) 혹은 액터(actor)로 분류 할 수 있다.
- 이들의 실제적인 실 세계의 요구사항을 끌어내, 소프트웨어 목표로 도출한다.
- 이런 요구사항들은 SuD(System under Discussion) 혹은 단순히 우리가 개발중인 소프트웨어에서 충족된다.


- SuD : 사용자 혹은 다른 시스템이 목표를 달성하기 위해 사용하는 시스템

- 드라이버 액터(driver actor) : SuD 행위 중 하나를 트리거하는 사용자 혹은 시스템
- 드리븐 엑터(driven actor) : SuD가 소비하는 외부 시스템


- 유스케이스 : 특정 상황에서 시스템 혹은 소프트웨어가 어떻게 작동해야 하는지 설명해주는 기법
  - SuD 목표
  - 목표를 충족하기 위한 수단이나 행위
  - 가능한 실패 시나리오
  - 실패시 수행해야 할 작업
- 유스케이스와 DDD 기법이 결합하는 경우, 유스케이스는 SuD(그리고 애플리케이션 헥사곤)에 더 큰 의미를 갖는 애플리케이션 특화 활동의 격차를 해소하는 중요한 역할을 한다.
- 유스케이스 측면에서 생각하면, 헥사고날 아키텍처에서 관심사의 분리를 개선하기 위한 중요한 단계를 밟는 것이다.

### 유스케이스 작성 방법
- Fully dressed Use Cases : 입력 데이터, 가능한 행위, 유스케이스 결과에 대한 상세하고 표준화된 정보를 규정하는 글로 작성된 상세 유스케이스.
- Example
```text
1. Actor : 인프라 엔지니어
2. Goal : 에지 라우터에 새로운 네트워크 추가
3. Scope : 인프라 부서
4. Trigger : 다른 네트워크를 통한 네트워크 엑세스를 분리하는 특별한 이유
5. Input Data : 라우터 ID, 네트워크 이름, 주소, CIDR
6. Actions : 
    6-1. 라우터 ID를 찾는다.
    6-2. 네트워크 주소가 이미 존재하는지 확인한다.
    6-3. CIDR이 최솟값 아래인지 확인한다.
    6-4. 이전 검사에서 문제가 없다면 통보된 라우터에 네트워크를 추가한다.
```


- 이와 반대되는 간단한 타입의 유스케이스는 정보가 어떻게 기록되어야 하는지에 대한 기준을 따르지 않는다. 이런 유스케이스는 한두문장에 최대한의 의미를 전달하려한다.
- Example
```text
인프라 엔지니어는 애플리케이션에 라우터 ID, 네트워크 이름, 주소, 그리고CIDR을 포함하는 요청을 보낸다. 
애플리케이션은 라우터 ID를 조회하고, 그것이 네트워크에 이미 존재하는지 여부를 확인한다.
그다음, CIDR 값이 허용된 최솟값 미만인지 확인하는 검사를 수행한다.
모든 검사가 정상이면 시스템은 통보된 라우터에 니트워크를 추가한다.
```


- 이 외에도 자동화된 테스트로 직접 사용자의 의도를 코드로 표현하는 것이 가능하다.
- 이 방법은 발견(discovery), 형식화(formulation), 자동화(automation)와 관련된 행위 주도 설계 원칙에 의존한다.
- 비즈니스 관련자의 요구를 "발견"하기 위해 대화를 통해 비즈니스 요구를 기술하는 상황과 행동에 대한 예제를 찾는다.
- 이러한 예제를 기반으로 구조화된 문서를 만들어 "형식화" 한다.
- 기술되고 구조화된 예제에서 나온 행동을 검증하기 위해 테스트를 만들어 "자동화" 한다.


- 소프트웨어 개발 초기 BDD를 사용할 떄 비즈니스 아이디어를 검증하기 위해 만든 예제와 테스트를 기반으로 반복적으로 유스케이스를 생성할 기회를 갖게 된다.
```text
@addNetworkRouter
Feature : 라우터에 네트워크를 추가한다.
기존 라우터에 네트워크를 추가할 수 있기를 원한다.

Scenario : 기존 라우터에 네트워크 추가
    Given : 라우터 ID와 네트워크 세부 사항을 제공한다.
    When : 라우터를 발견했다.
    And : 네트워크 주소가 유효하며 기존에 존재하지 않는다.
    And : CIDR이 유효하다.
    Then : 라우터에 네트워크를 추가한다.
```

- 그 이후 기능 파일에서 Given, When, And, Then 용오가 제공하는 단계를 기반으로 유스케이스 단계의 유효성 검사를 자동화하는 테스트 클래스를 작성한다.
```java
public class AddNetworkSteps {
    RouterId routerId;
    Router router;
    
    RouterNetworkFileAdaptor routerNetworkFileAdaptor = RouterNetworkFileAdaptor.getInstance();
    
    Network network = new Network(new IP("20.0.0.0"), "Marketing", 8);
    
    /** Rest of the Code**/
}
```
- 테스트 수행에 사용할 객체를 선언하고 초기화한다. RouterId와 Router 타입을 선언하고, RouterNetworkFileAdapter 와 Network 인스턴스를 초기화했다.
- 테스트에 필요한 리소스를 준비하고, 테스트의 첫 단계를 구현한다.
```java
@Given("I provide a router ID and the network details")
public void obtail_router_Id() {
    this.routerId = RouterId.withId("ca23800e-9b5a-11eb-a8b3-0242ac130003");
}
```
- @Given은 RouterID의 검색을 기술한다. 라우터를 가져오기 위해 ID를 사용한다.


```java
@When("I found the router")
public void lookup_router() {
    router = routerNetworkFileAdapter.fetchRouterById(routerId);
}
```
- RouterNetworkFileAdapter와 RouterId를 사용해 Router객체를 검색한다. 그다음, Network 객체를 라우터에 추가하기 전에 해당 객체가 원하는 요구사항을 만족하는지 검사한다.

```java
@And("The network address is valid and doesn't already exist")
public void check_address_validity_and_existence() {
        var availabilitySpec = new NetworkAvailabilitySpecification(network.getAddress(), network.getName(), network.getCidr());
        
        if(!availabilitySpec.isSatisfiedBy(router)){
        throw new IllegalArgumentException("Address already exist");
        }
}

```

- 네트워크가 유효한지 확인하려면 NetworkAvailabilitySpecification 규칙을 반드시 적용해야 한다. 다음으로 네트워크 CIDR을 확인해야 한다.
```java
@Given("The CIDR is valid")
public void check_cidr() {
    var cidrSpec = new CIDRSpecification();
    
    if(cidrSpec.isSatisfiedBy(network.getCidr())){
        throw new IllegalArgumentException("CIDR is below"+CIDRSpecification.MINIMUM_ALLOWED_CIDR);
        }
}

```

- 마지막 유효성 검사 단계로 CIDRSpecification 규칙을 적용한다. 모든 것이 정상이면 스위치에 네트워크를 추가할 수 있다.
```java
@Then("Add the network to the router")
public void add_network() {
    router.addNetworkToSwitch(network);
}

```

- Router에서 addNetworkToSwitch 메서드를 호출해 라우터에 네트워크를 추가한다.

- 다음 그림은 형식적이고 간단한 BDD 기반의 유스케이스 타입의 시각적인 표현이다.
![3_1image.PNG](images%2F3_1image.PNG)

- 완전 형식 유스케이스, 간단한 유스케이스, BDD 기반 유스케이스 모두 같은 것을 표현하고 있다.
- 이들의 주된 차이점은 what이 아니라 이 세가지 유스케이스가 어떻게(how) 시스템 행위를 설명하냐에 있다.
- 이를 선택하는데 있어 주된 논점은 비용, 시간 그리고 조직의 제약사항에 달려있다.


- 유스케이스 생성/처리를 건너뛰고 하고 코드 작업을 할 수도 있다. (저자는 형식적 유스케이스 구성 파트를 필수로 생각하지 보단 권장한다는 입장이다.)
- 유스케이스의 예상 행위를 기록하고 구성함으로써 유스케이스의 수월환 조직화를 위한 아이디어를 정리하고 명확하게 할 수 있다.
- 이 구조 작업이 완료되면 유스케이스를 그에 대응하는 코드로 번역한다.


- 헥사고날 애플리케이션을 개발할 때 제안하는 유스케이스 디자인 방법은 구현보다는 추상적 개념으로 디자인 하는 것이다.
- 인터페이스뿐만 아니라 추상 클래스를 사용해도 좋다.
```java
public interface RouterNetworkUseCase {
    Router addNetworkToRouter(RouterId routerId, Network network);
}
```

- 우리는 다음 3가지 이유로 유스케이스를 추상적 개념으로 디자인 한다.
  1. 유스케이스를 달성하기 위한 여러 다른 방법 제공
  2. 구현보다는 추상화에 대한 의존성 허용
  3. API의 관리를 위해(원서에는 있는데 번역된 책에는 없음)
  
![3reasons.PNG](images%2F3reasons.PNG)

- 헥사고날 아키텍처에서 유스케이스의 역할은 우리가 입력 포트 구현하는 것을 허용하는 것이다.
- 우리는 입력 포트를 통해 도메인 헥사곤 서비스 호출, 다른 유스케이스 호출, 출력 포트를 통한 외부 리소스를 호출하는 로직을 구성한다.
- 유스케이스와 유스케이스 입력 포트에 대한 UML 표현은 다음과 같다.
![3_2usecase.PNG](images%2F3_2usecase.PNG)

- 이제 글 형식과 코드 형식으로 유스케이스 만드는 방법을 배웠으니 입력 포트를 가진 유스케이스를 구현하는 방법을 알아보자.
## 입력 포트를 갖는 유스케이스 구현
## 출력 포트를 이용한 외부 데이터 처리
## 애플리케이션 헥사곤을 통한 동작 자동화


















































