# 포트와 유스케이스를 통한 동작 처리
## 유스케이스를 통한 소프트웨어 동작 표현
- 소프트웨어 시스템 : 어떤 목표를 달성하기 위해 함께 동작하는 "소프트웨어의 동작"들을 모아둔것
- 소프트웨어의 동작 : 혼자, 혹은 다른 소프트웨어 동작과 함께 가치 있는 "소프트웨어 목표"(사용자 혹은 다른 소프트웨어 시스템이 정의한)를 실현하기 위해 기여하는 의미있는 행동
- 소프트웨어 목표 : 관심있는 사용자나 시스템이 명시하는 요구사항과 밀접하게 연결되어 있다.


- 사용자나 시스템을 이해당사자(stakeholders) 혹은 액터(actor)로 분류 할 수 있다.
- 이들의 실제적인 실 세계의 요구사항을 끌어내, 소프트웨어 목표로 도출한다.
- 이런 요구사항들은 SuD(System under Discussion) 혹은 단순히 우리가 개발중인 소프트웨어에서 충족된다.


- SuD : 사용자 혹은 다른 시스템이 목표를 달성하기 위해 사용하는 시스템

- 드라이버 액터(driver actor) : SuD 행위 중 하나를 트리거하는 사용자 혹은 시스템
- 드리븐 엑터(driven actor) : SuD가 소비하는 외부 시스템


- 유스케이스 : 특정 상황에서 시스템 혹은 소프트웨어가 어떻게 작동해야 하는지 설명해주는 기법
  - SuD 목표
  - 목표를 충족하기 위한 수단이나 행위
  - 가능한 실패 시나리오
  - 실패시 수행해야 할 작업
- 유스케이스와 DDD 기법이 결합하는 경우, 유스케이스는 SuD(그리고 애플리케이션 헥사곤)에 더 큰 의미를 갖는 애플리케이션 특화 활동의 격차를 해소하는 중요한 역할을 한다.
- 유스케이스 측면에서 생각하면, 헥사고날 아키텍처에서 관심사의 분리를 개선하기 위한 중요한 단계를 밟는 것이다.

### 유스케이스 작성 방법
- Fully dressed Use Cases : 입력 데이터, 가능한 행위, 유스케이스 결과에 대한 상세하고 표준화된 정보를 규정하는 글로 작성된 상세 유스케이스.
- Example
```text
1. Actor : 인프라 엔지니어
2. Goal : 에지 라우터에 새로운 네트워크 추가
3. Scope : 인프라 부서
4. Trigger : 다른 네트워크를 통한 네트워크 엑세스를 분리하는 특별한 이유
5. Input Data : 라우터 ID, 네트워크 이름, 주소, CIDR
6. Actions : 
    6-1. 라우터 ID를 찾는다.
    6-2. 네트워크 주소가 이미 존재하는지 확인한다.
    6-3. CIDR이 최솟값 아래인지 확인한다.
    6-4. 이전 검사에서 문제가 없다면 통보된 라우터에 네트워크를 추가한다.
```


- 이와 반대되는 간단한 타입의 유스케이스는 정보가 어떻게 기록되어야 하는지에 대한 기준을 따르지 않는다. 이런 유스케이스는 한두문장에 최대한의 의미를 전달하려한다.
- Example
```text
인프라 엔지니어는 애플리케이션에 라우터 ID, 네트워크 이름, 주소, 그리고CIDR을 포함하는 요청을 보낸다. 
애플리케이션은 라우터 ID를 조회하고, 그것이 네트워크에 이미 존재하는지 여부를 확인한다.
그다음, CIDR 값이 허용된 최솟값 미만인지 확인하는 검사를 수행한다.
모든 검사가 정상이면 시스템은 통보된 라우터에 니트워크를 추가한다.
```


- 이 외에도 자동화된 테스트로 직접 사용자의 의도를 코드로 표현하는 것이 가능하다.
- 이 방법은 발견(discovery), 형식화(formulation), 자동화(automation)와 관련된 행위 주도 설계 원칙에 의존한다.
- 비즈니스 관련자의 요구를 "발견"하기 위해 대화를 통해 비즈니스 요구를 기술하는 상황과 행동에 대한 예제를 찾는다.
- 이러한 예제를 기반으로 구조화된 문서를 만들어 "형식화" 한다.
- 기술되고 구조화된 예제에서 나온 행동을 검증하기 위해 테스트를 만들어 "자동화" 한다.


- 소프트웨어 개발 초기 BDD를 사용할 떄 비즈니스 아이디어를 검증하기 위해 만든 예제와 테스트를 기반으로 반복적으로 유스케이스를 생성할 기회를 갖게 된다.
```text
@addNetworkRouter
Feature : 라우터에 네트워크를 추가한다.
기존 라우터에 네트워크를 추가할 수 있기를 원한다.

Scenario : 기존 라우터에 네트워크 추가
    Given : 라우터 ID와 네트워크 세부 사항을 제공한다.
    When : 라우터를 발견했다.
    And : 네트워크 주소가 유효하며 기존에 존재하지 않는다.
    And : CIDR이 유효하다.
    Then : 라우터에 네트워크를 추가한다.
```

- 그 이후 기능 파일에서 Given, When, And, Then 용오가 제공하는 단계를 기반으로 유스케이스 단계의 유효성 검사를 자동화하는 테스트 클래스를 작성한다.
```java
public class AddNetworkSteps {
    RouterId routerId;
    Router router;
    
    RouterNetworkFileAdaptor routerNetworkFileAdaptor = RouterNetworkFileAdaptor.getInstance();
    
    Network network = new Network(new IP("20.0.0.0"), "Marketing", 8);
    
    /** Rest of the Code**/
}
```
- 테스트 수행에 사용할 객체를 선언하고 초기화한다. RouterId와 Router 타입을 선언하고, RouterNetworkFileAdapter 와 Network 인스턴스를 초기화했다.
- 테스트에 필요한 리소스를 준비하고, 테스트의 첫 단계를 구현한다.
```java
@Given("I provide a router ID and the network details")
public void obtail_router_Id() {
    this.routerId = RouterId.withId("ca23800e-9b5a-11eb-a8b3-0242ac130003");
}
```
- @Given은 RouterID의 검색을 기술한다. 라우터를 가져오기 위해 ID를 사용한다.


```java
@When("I found the router")
public void lookup_router() {
    router = routerNetworkFileAdapter.fetchRouterById(routerId);
}
```
- RouterNetworkFileAdapter와 RouterId를 사용해 Router객체를 검색한다. 그다음, Network 객체를 라우터에 추가하기 전에 해당 객체가 원하는 요구사항을 만족하는지 검사한다.

```java
@And("The network address is valid and doesn't already exist")
public void check_address_validity_and_existence() {
        var availabilitySpec = new NetworkAvailabilitySpecification(network.getAddress(), network.getName(), network.getCidr());
        
        if(!availabilitySpec.isSatisfiedBy(router)){
        throw new IllegalArgumentException("Address already exist");
        }
}

```

- 네트워크가 유효한지 확인하려면 NetworkAvailabilitySpecification 규칙을 반드시 적용해야 한다. 다음으로 네트워크 CIDR을 확인해야 한다.
```java
@Given("The CIDR is valid")
public void check_cidr() {
    var cidrSpec = new CIDRSpecification();
    
    if(cidrSpec.isSatisfiedBy(network.getCidr())){
        throw new IllegalArgumentException("CIDR is below"+CIDRSpecification.MINIMUM_ALLOWED_CIDR);
        }
}

```

- 마지막 유효성 검사 단계로 CIDRSpecification 규칙을 적용한다. 모든 것이 정상이면 스위치에 네트워크를 추가할 수 있다.
```java
@Then("Add the network to the router")
public void add_network() {
    router.addNetworkToSwitch(network);
}

```

- Router에서 addNetworkToSwitch 메서드를 호출해 라우터에 네트워크를 추가한다.

- 다음 그림은 형식적이고 간단한 BDD 기반의 유스케이스 타입의 시각적인 표현이다.
![3_1image.PNG](images%2F3_1image.PNG)

- 완전 형식 유스케이스, 간단한 유스케이스, BDD 기반 유스케이스 모두 같은 것을 표현하고 있다.
- 이들의 주된 차이점은 what이 아니라 이 세가지 유스케이스가 어떻게(how) 시스템 행위를 설명하냐에 있다.
- 이를 선택하는데 있어 주된 논점은 비용, 시간 그리고 조직의 제약사항에 달려있다.


- 유스케이스 생성/처리를 건너뛰고 하고 코드 작업을 할 수도 있다. (저자는 형식적 유스케이스 구성 파트를 필수로 생각하기 보단 권장한다는 입장이다.)
- 유스케이스의 예상 행위를 기록하고 구성함으로써 유스케이스의 수월환 조직화를 위한 아이디어를 정리하고 명확하게 할 수 있다.
- 이 구조 작업이 완료되면 유스케이스를 그에 대응하는 코드로 번역한다.


- 헥사고날 애플리케이션을 개발할 때 제안하는 유스케이스 디자인 방법은 구현보다는 추상적 개념으로 디자인 하는 것이다.
- 인터페이스뿐만 아니라 추상 클래스를 사용해도 좋다.
```java
public interface RouterNetworkUseCase {
    Router addNetworkToRouter(RouterId routerId, Network network);
}
```

- 우리는 다음 3가지 이유로 유스케이스를 추상적 개념으로 디자인 한다.
  1. 유스케이스를 달성하기 위한 여러 다른 방법 제공
  2. 구현보다는 추상화에 대한 의존성 허용
  3. API의 관리를 위해(원서에는 있는데 번역된 책에는 없음)
  
![3reasons.PNG](images%2F3reasons.PNG)

- 헥사고날 아키텍처에서 유스케이스의 역할은 우리가 입력 포트 구현하는 것을 허용하는 것이다.
- 우리는 입력 포트를 통해 도메인 헥사곤 서비스 호출, 다른 유스케이스 호출, 출력 포트를 통한 외부 리소스를 호출하는 로직을 구성한다.
- 유스케이스와 유스케이스 입력 포트에 대한 UML 표현은 다음과 같다.
![3_2usecase.PNG](images%2F3_2usecase.PNG)

- 이제 글 형식과 코드 형식으로 유스케이스 만드는 방법을 배웠으니 입력 포트를 가진 유스케이스를 구현하는 방법을 알아보자.


## 입력 포트를 갖는 유스케이스 구현
- 드라이빙 오퍼레이션 : 소프트웨어에 동작을 요청하는 것
- 드리븐 오퍼레이션 : 애플리케이션에서 트리거되고, 외부(드리븐 엑터?)에서 소프트웨어 요구사항을 충족시키는 데 필요한 데이터를 가져오는 것
- 위 두가지 분류로 헥사고날 시스템과 상호작용하는 액터를 결정하는데 유용한 역할을 한다.
- 드라이빙 액터 : 애플리케이션에 요청을 보내는 사람/시스템
- 드리븐 액터 : 애플리케이션에서 액세스하는 외부 컴포넌트


- 유스 케이스는 애플리케이션이 어떤 동작을 지원하는지 알려준다면, 입력 포트는 동작들이 어떻게 수행되는지 알려준다.


- 입력 포트 : 기본 포트라고도 불리며 드라이빙 액터와 드라이빙 오퍼레이션 사이 통신을 하기 위해 사용한다.
  - 입력 포트는 드라이빙 액터로부터 받은 데이터가 프레임워크 헥사곤의 어댑터 중 하나를 통해 헥사고날 시스템에 도달할수 있도록 하는 파이프라 볼 수 있다.
  - 입력 포트는 도메인 헥사곤에 정의된 비즈니스 규칙과 통신하기 위한 파이프 역할을 한다.
  - 입력 포트를 통해 우리는 출력 포트와 어댑터를 통한 외부 시스템과의 통신도 조정한다.
  - 입력 포트는 헥사고날 시스템의 교차로(중심지)에 위치한다.
  - 외부로부터 들어오는 것들을 변환하여 도메인/애플리케이션 헥사곤 방향으로 이동하는데 도움을 준다.
![3_3inputports.PNG](images%2F3_3inputports.PNG)

- 이전에 정의한 네트워크를 라우터에 추가하는 유스케이스 인터페이스를 구현해 입력 포트를 만드는 방법을 보자
```java
// 유스케이스 목표를 만족시키기 위해 소프트웨어가 수행해야 하는 동작에 대한 명확한 뷰
public class RouterNetworkInputPort implements RouterNetworkUseCase {
    
    private final RouterNetworkOutputPort routerNetworkOutputPort;
    
    public RouterNetworkInputPort(RouterNetworkOutputPort routerNetworkOutputPort){
        this.routerNetworkOutputPort = routerNetworkOutputPort;
    }

    @Override
    public Router addNetworkToRouter(RouterId routerId, Network network) {
        var router = fetchRouter(routerId);
        
        return createNetwork(router, network);
    }
    
    private Router fetchRouter(RouterId routerId) {
        return routerNetworkOutputPort.fetchRouterById(routerId);
    }
    
    private Router createNetwork(Router router, Network network) {
        var newRouter = NetworkOperation.createNewNetwork(router, network);
        
        return persistNetwork(router) ? newRouter : router;
    }
    
    private boolean persistNetwork(Router router) {
        return routerNetworkOutputPort.persistRouter(router);
    }
}
```


- RouterNetworkOutputPort 인터페이스의 선언
```java
public interface RouterNetworkOutputPort {
    Router fetchRouterById(RouterId routerId);
    boolean persistRouter(Router router);
}
```
- 이 인터페이스에서 우리는 오직 외부에서 데이터를 가져오려는 의도만 명시했다.
- 헥사곤 시스템은 외부 소스가 무엇인지 알지 못한다.

-  fetchRouter 메서드는 출력 포트의 fetchRouterById를 사용해 Router 객체를 얻어야하는데, 이때 입력포트는 출력 포트를 구현하는 출력 어댑터에 의해 수행될 외부 호출을 조정한다. (?)


- 해당 입력 포트의 메인 관심사는 도메인 서비스를 통한 내부 호출 및 외부 포트를 통한 외부 호출 조정 및 데이터 처리이다.
  - 오퍼레이션 실행 순서를 설정하고, 도메인 헥사곤이 이해할 수 있도록 데이터를 가공하여 제공한다.


## 출력 포트를 이용한 외부 데이터 처리
- 출력 포트 : 보조 포트라고도 부르며 외부 데이터를 처리하려는 애플리케이션의 의도를 나타낸다.
  - 우리는 출력 포트를 통해 시스템이 외부 세계와 통신할 수 있도록 준비하고, 이러한 통신을 통해 출력 포트를 드리븐 액터 그리고 오페레이션과 연관짓는다.
- 드리븐 액터는 외부 시스템이지만, 드리븐 오퍼레이션은 이런 외부 시스템과 통신하기 위해 사용된다.
- 출력 포트를 통해 시스템이 외부 세계와 통신할 수 있도록 준비한다고 설명한 이유는 : 
  - 애플리케이션 헥사곤 레벨에서는 통신이 어떻게(how) 발생할지 아직 알 수 없기 때문이다.
  - 이는 어떤 기술 사용에 대한 결정을 최대한 미루라는 엉클 밥의 말을 기반으로 한다.
  - 이렇게 하면 우리는 기술적인 세부사항보다 문제 영역에 더 집중할 수 있고, 외부 기술이 애플리케이션의 설계 방법을 지시하지 않게 한다.


### 리포지토리만 문제가 아니다
- 헥사고날 애플리케이션에서는 리포지토리를 출력 포트로 대체한다.
- 리포지토리는 간혹 데이터베이스 오퍼레이션과 연관되며, 사실 (리포지토리와 데이터베이스 오퍼레이션간의)연관성을 공식화 하기 위해 일부 개발 프레임워크가 제공하는 지속성 기능을 통해 강제(적용)된다.
  - 지속성 기능이란 -> 저장 시스템(데이터베이스 같은)에 데이터를 저장하거나 가져오기 위해 프레임워크나 라이브러리에서 제공하는 기능
```java
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Long> { 
    PasswordResetToken findByToken(String token);
    
    PasswordResetToken findByUser(User user);
    
    Stream<PasswordResetToken>
    
    findAllByExpiryDateLessThan(Date now);
    
    void deleteByExpiryDateLessThan(Date now);
    
    @Modifying
    @Query("delete from PasswordResetToken t where t.expiryDate <= ?1") 
    void deleteAllExpiredSince(Date now);
}

```

- 스프링 프레임워크의 JpaRepository 인터페이스와 @Query 애노테이션의 사용은 해당 리포지토리와 데이터베이스간의 연관성을 공식화 한다. 즉 패스워드 데이터가 데이터베이스에서 제공된다는 개념을 강화한다.


- 출력 포트의 기본 개념은 지속성이나 모든 종류의 외부 통신이 데이터베이스 시스템에서 발생할 것이라 추론하지 않는것이다. 출력 포트는 모든 시스템과의 통신에 관심을 갖는다.

```java
public interface PasswordResetTokenOutputPort {
    PasswordResetToken findByToken(String token);
    
    PasswordResetToken findByUser(User user);
    
    Stream<PasswordResetToken>
    
    findAllByExpiryDateLessThan(Date now);
    
    void deleteByExpiryDateLessThan(Date now);
    
    void deleteAllExpiredSince(Date now);
}

```

- 특정 프레임워크에서 타입을 확장하거나 @Query 같은 애노테이션의 사용을 피함으로써 출력 포트를 POJO로 바꾼다.
  - 애노테이션 사용 자체는 문제가 없으나 애노테이션 사용 목적이 문제가 될 수 있다. 예를 들어 특정 프레임워크에 종속적인 기능을 구현하기 위해 애노테이션을 사용한다면 소프트웨어와 프레임워크가 결합하게 된다.

- 애플리케이션 헥사곤의 관점에서 데이터를 어디서 가져왔는지는 중요하지 않다. 애초에 애플리케이션 헥사곤의 컴포넌트들은 어떻게 데이터를 가져왔는지 관심이 없다.
- 애플리케이션 헥사곤의 주요 관심사는 그들의 액티비티를 수행하기 위해 어떤 데이터가 필요한지 표현하는 것이다.
- 애플리케이션 헥사곤의 컴포넌트가 자신들이 어떤 데이터를 필요로 하는지 정의하는 방법은 도메인 헥사곤의 엔티티와 값 객체를 기반으로 한다.
  - 이렇게 출력 포트가 필요로 하는 데이터 타입만을 명시하면, 우리는 동일한 출력 포트에 여러가지 다른 어댑터를 연결할 수 있게 되고,
  - 이 어탭터들은 출력 포트에서 요구하는 데이터를 얻기 위해 필요한 작업들을 수행한다.
![3_4adapter.PNG](images%2F3_4adapter.PNG)
- 출력 포트의 주된 목표는 데이터를 가져오는 방법을 지정하지 않은채, 어떤 데이터가 필요한지 명시하는 것이다. 그렇기에 출력 포트를 interface로 정의하는 것.


### 어디에 출력 포트를 사용하는가?
- 출력 포트를 만들고 활용하는 이유는 유스케이스에서 수행하는 활동 때문일 것이다.
- 코드 상에는 출력 포트에 대한 참조는 유스케이스의 인터페이스 선언에는 나타나지 않는다.
  - 출력 포트는 우리가 인풋포트를 통해 유스케이스를 구현할 때 명시적으로 사용된다.
  - 이것은 우리가 RouterNetworkUseCase를 구현하고 있는 RouterNetworkInputPort의 시작 부분에서 RouterNetworkOutputPort속성을 선언했을 때 한 일이다.
```java
public class RouterNetworkInputPort implements RouterNetworkUseCase {
    private final RouterNetworkOutputPort routerNetworkOutputPort;
    
    public RouterNetworkInputPort(RouterNetworkOutputPort routerNetworkOutputPort){
        this.routerNetworkOutputPort = routerNetworkOutputPort;
    }
    
    private Router fetchRouter(RouterId routerId) {
        return routerNetworkOutputPort.fetchRouterById(routerId);
    }

    private boolean persistNetwork(Router router) {

        return routerNetworkOutputPort.persistRouter(router);
    }
}

```

- 출력포트의 인스턴스를 언제, 어떻게 생성하는지 궁금할 수 있다. 이전 예제에서는 입력 포트 생성자가 출력 포트 객체에 대한 참조를 수신하는 방법을 쓰고 있는데, 이 출력 포트 객체는 출력 어댑터가 제공하는 구현일 것이다.
- 유스케이스에서 정의되고 입력 포트에서 구현되는 오퍼레이션 중 일부는 외부소스에서 데이터를 가져오거나 외부소스에 저장하여 데이터를 유지하는 역할을 한다.
  - 유스케이스의 목표를 달성하기 위해 필요한 데이터의 제공을 출력 포트가 담당한다.


## 애플리케이션 헥사곤을 통한 자동화
- 자동화(Automation)은 소프트웨어가 할 수 있는 가장 가치 있는 일 중 하나다.
- 초기 신용카드 산업은 사용하기 번거로웠다. 매장과 은행의 크로스 체크 등...
- 하지만 기술의 발전이 이러한 작업을 자동화 시켰다.

- 만약 헥사고날 아키텍처를 사용해 이러한 신용카드 검증 시스템을 만들기로 한다면, 
  - 카드 소유자의 신용을 확인하기 위해 필요한 단계를 "유스케이스"를 통해 표현할 수 있다.
  - "입력 포트"를 통해 유스케이스의 목표를 달성하기 위한 비즈니스 규칙과 필요한 데이터를 처리할 수 있고, 필요시에는 "출력 포트"를 사용해 외부 시스템에 대한 처리를 할 수 있다.
```java
// 1. We start by creating a CreditCard entity class:
public class CreditCard {
    /** Code omitted **/
    double availableCredit;
    
    public boolean isAvailableCreditGreaterOrEqualThan(double transactionAmount) {
        return availableCredit>=transactionAmount;
    }
}

```
- 위 코드는 신용 가용성 측면만 강조한다. 그래서 availableCredit 속성과 isAvailableCreditGreaterOrEqualThan 메서드를 통해 해당 거래에 대한 신용(자산)이 충분한지 확인한다.

```java
//2. Then, we declare the CreditCheckUseCase interface:
public interface CreditCheckUseCase {
    boolean hasEnoughCredit(String cardId, double transactionAmount);
}

```
- 여기서의 목적은 신용카드가 해당 거래 금액에 대한 충분한 신용(자산)이 있는지 확인하는 것이다. 이를 확인하기 위해 cardId와 transactionAmount가 필요하다.
- cardId는 어딘가에서 신용카드의 정보를 가져올 때 사용될것이므로 "출력 포트"가 필요하다.

```java
//3. Here, we declare CreditCheckOutputPort:
public interface CreditCheckOutputPort {
    CreditCard getCreditCard(String cardId);
}
```
- cardId로 신용카드 정보를 가져오는 출력 포트이다. 해당 신용카드 정보에는 얼만큼의 자산이 있는지의 정보가 필요하다.

```java
//4. Suppose credit card data is stored in a MySQL database. We would need an output adapter that implements the previously defined output port:
public class CreditCheckMySQLOutputAdapter implements CreditCheckOutputPort {
    @Override
    public CreditCard getCreditCard(String cardId) {
        /** Code omitted **/
        return creditCard;
    }
}
```
- getCreditCard 메서드 내부에는 데이터베이스로부터 가져온 데이터를 CreditCard 도메인 엔티티 객체로 변환해주는 기능이 필요할것이다.
```java
//5. Finally, we can create the input port by implementing the CreditCheckUseCase interface:
public class CreditCheckInputPort implements CreditCheckUseCase {
    CreditCheckOutputPort creditCheckOutputPort;
    
    @Override
    public boolean hasEnoughCredit(String cardId, double transactionAmount) {
        return getCreditCard(cardId).isAvailableCreditGreaterOrEqualThan(transactionAmount);
    }
    
    private CreditCard getCreditCard(String cardId) {
        return creditCheckOutputPort.getCreditCard(cardId);
    }
    
}
```
- CreditCheckInputPort는 hasEnoughCredit메서드에서 사용하기 위한 신용카드 정보를 CreditCheckOutPutPort에 의존하여 가지고 온다.


- 애플리케이션 헥사곤을 구현하는 한가지 이점은 자동화 시스템을 위해 어떤 기술을 사용할지 지정할 필요가 없다는 것이다.
- 이렇게 기술적 세부사항에 초점을 맞추지 않기 때문에 헥사고날 시스템이 다른 기술과 더 쉽게 통합될 수 있는 것이다.











































