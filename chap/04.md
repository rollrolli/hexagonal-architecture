# 외부와 상호작용하는 어댑터 만들기
## 어댑터 이해
- 헥사고날 아키텍쳐에서는 시스템이 다른 기술이나 프로토콜과 호환되게 만들기 위해 어댑터를 사용
- 애플리케이션 헥사곤과 도메인 헥사곤에서 제공하는 기능을 외부 클라이언트가 사용할 수 있도록 하기 위해 일종의 프로토콜 역할을 하는것이 어댑터이다.
  - 예를들어 REST와 gRPC를 위해 기능을 제공하고자 한다면, 그에 맞춰 REST 어댑터와 gRPC 어댑터를 만들어야 한다.
  - 이런 어댑터를 입력 어댑터라 부른다.
![4_1.PNG](images%2F4_1.PNG)
  - REST 어댑터, gRPC 어댑터와 같은 입력 어댑터를 시스템의 나머지 부분에 연결하기 위해 위 그림처럼 입력 포트를 입력 어댑터와 연결 시킨다.
- 입력 어댑터와 출력 어댑터는 모두 프레임워크 헥사곤 가장 바깥에 위치한다.
![4_2.PNG](images%2F4_2.PNG)

## 드라이빙 오퍼레이션 허용을 위한 입력 어댑터 사용
- 입력 어댑터 : 헥사고날 시스템이 제공하는 시스템에 접근하기 위한 수단으로 지원되는 기술을 정의한다.
- 입력 어댑터 : 헥사곤 내부와 외부 사이의 명확한 경계를 표시하고 드라이빙 오퍼레이션을 수행한다.
  - 드라이빙 오퍼레이션 : 소프트웨어에 동작을 요청하는 것


- 헥사곤 애플리케이션과 주요 액터(primary actor)간의 상호 작용은 입력 어댑터를 통해 일어난다.
  - 주요 액터가 헥사고날 시스템의 상태와 행위에 영향을 주기때문에 이러한 상호작용을 "드라이빙" 오퍼레이션이라 한다.
- 입력 어댑터는 헥사고날 시스템을 와부 세계에 노출시킨다.


- DDD 에서는 시스템이 다른 기술이나 프로토콜과 호환되도록 하는 목적 외에 어댑터를 사용하는 다른 목적을 제안한다.

- DDD 기반 아키텍처에서 일반적으로 우려하는 것은 레거시 시스템의 요소를 새로운 시스템에 통합하는 것이다.
  - 이 우려사항은 도메인 모델에 압축된 관련 지식을 가진 레거시 시스템이 일부 중요한 문제를 해결하고있지만, 그 시스템 설계에 불일치가 나타나는 시나리오에서 발생한다.
- 시스템을 통합하는 상황에서 우리는 레거시 시스템을 포기하고 싶지도 않고, 새로운 시스템 설계가 레거시 시스템 설계에 영향을 받는것도 원하지 않을 것이다.
- 이런 상황에 대처하기 위해 반부패 계층(anti-corruption layer)를 사용할 수 있다.
  - 이 계층은 기존 시스템과 새로운 시스템 모두에서 경계 컨텍스트를 통합하는 데 사용되는 어댑터를 기반으로 합니다.
- https://codebots.com/way-of-working/activity-bubble-context-and-anti-corruption-layer
- 이런 상황에서 어댑터는 새로운 시스템의 설계가 레거리 시스템의 설계로 인해 오염되는 것을 방지한다.


- 헥사고날 설계에서는 어댑터를 이런 식으로 사용하지는 않겠지만, 헥사고날 시스템에서는 DDD 기반 어댑터 접근 방식을 사용할 수도 있다. (두개가 다름?)
### 입력 어댑터 생성
- Input Ports : 유스케이스를 구현하는 수단으로서, 우리는 input port 가 유스케이스의 목표를 달성하기 위해 어떻게 작업을 수행하는지 지정한다.
- 입력 포트 객체가 작업을 수행하기 위해서는 Stimulus 라는 것을 받아야 하는데 이는 다른 객체를 호출하는 객체일 뿐이다.
- 입력 포트 객체는 입력 어댑터로부터 전달받은 Stimulus 로부터 작업을 수행하기 위해 필요한 데이터를 받는데, 이때 입력 데이터가 도메인 헥사곤과 호환될 수 있도록 변환이 이루어질 수도 있다. 
![4_3.PNG](images%2F4_3.PNG)
- 어댑터 추상 기반 클래스 하나를 정의하고, 두개의 구현 클래스를 만들 것이다.
  - HTTP REST 연결로 데이터를 받는 용도의 어댑터
  - 콘솔 STDIN 연결로 데이터를 받는 용도의 어댑터
- 이 두 어댑터에 대한 액세스를 시뮬레이션하기 위해 응용 프로그램을 부트스트랩할 클라이언트 클래스를 만든다.

```java
// 기반 어댑터
// RouterNetworkAdapter 추상 기반 클래스를 정의한다.
public abstract class RouterNetworkAdapter {
    
    protected Router router;
    protected RouterNetworkUseCase routerNetworkUseCase;
    
    protected Router addNetworkToRouter(Map<String, String> params) {
        var routerId = RouterId.withId(params.get("routerId"));
        var network = new Network(IP.fromAddress(params.get("address")), params.get("name"), Integer.valudOf(params.get("cidr")));
        
        return routerNetworkUseCase.addNetworkToRouter(routerId, network);
    }
    
    public abstract Router processRequest(Object requestParam);
}
```
- 이 base 어댑터는 각 어댑터와 연관된 입력 포트와 통신을 위한 표준 오퍼레이션을 제공하기 위함이다.
- addNetworkToRouter 어댑터 메서드를 통해 routerId와 network 객체를 생성하기 위해 필요한 파라미터를 받는다.
  - 이 두 객체들은 라우터에 네트워크를 등록하는 유스케이스 오퍼레이션을 시작하기 위해 사용된다.
- 객체 생성을 위한 파라미터는 서로 다른 소스에서 받을 수 있지만(HTTP, STDIN등) addNetworkToRouter에서는 동일한 방법으로 처리된다.

- 유스케이스 인터페이스 참조를 활용하는데, 이 참조는 입력 어댑터의 생성자에 의해 전달되고 초기화된다.

```java
// REST 입력 어댑터
//RouterNetworkRestAdapter 생성자를 정의한다.
public RouterNetworkRestAdapter(RouterNetworkUseCase routerNetworkUseCase) { //책 오타(outerNetworkUseCase -> routerNetworkUseCase)
    this.routerNetworkUseCase = routerNetworkUseCase;
}
```
- RouterNetworkUseCase 유스케이스 참조를 받고 초기화하기 위해 RouterNetworkRestAdapter 생성자를 사용한다.
```java
// 클라이언트가 RouterNetworkRestAdapter 입력 어댑터를 호출하고 초기화하는 방법
RouterNetworkOutputPort outputPort = RouterNetworkH2Adapter.getInstance();
RouterNetworkUseCase usecase = new RouterNetworkInputPort(outputPort);
RouterManageNetworkAdapter inputAdapter = new RouterNetworkRestAdapter(usecase);
```
- 이 코드에서의 의도는 REST 입력 어댑터가 H2 in-memory 데이터베이스 출력 어댑터를 필요로 한다는 것을 표현하는 것이다.
- 여기선 입력 어댑터가 작업을 수행하기 위해 필요한 출력 어댑터를 명시적으로 서술했지만, 나중에 이런 어댑터 생성자는 전부 치워버리고, 스프링이나 쿼커스에서 제공하는 의존성 주입 애노테이션을 사용할 수 있다.

```java
// RouterNetworkAdapter 생성자를 정의한 후, processRequest 메서드를 구현한다.
/**
 * REST 어댑터를 구현할 때, processRequest메서드는 Object 타입의 requestParams를 받아 HttpServer 타입으로 변환한다.
 */
@Override
public Router processRequest(Object requestParams) {
    Map<String, String> params = new HashMap<>();
    
    if(requestParams instanceof HttpServer) {
        var httpserver = (HttpServer) requestParams;
        httpserver.createContext("/network/add", (exchange -> {
            if ("GET".equals(exchange.getRequestMethod())) {
                var query = exchange.getRequestURI().getRawQuery();
                httpParams(query, params);
                
                router = this.addNetworkToRouter(params);
                ObjectMapper mapper = new ObjectMapper();
                var routerJson = mapper.writeValueAsString(RouterJsonFileMapper.toJson(router));
                
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.sendResponseHeaders(200, routerJson.getBytes().length);
                
                OutputStream output = exchange.getResponseBody();
                output.write(routerJson.getBytes());
                output.flush();
            } else {
                exchange.sendResponseHeaders(405, -1);
            }
            exchange.close();
        }));
        
        httpserver.setExecutor(null);
        httpserver.start();
    }
    return router;
}
```
- 이 메서드는 /network/add 에서 GET 요청을 받기 위한 HTTP 엔드 포인트를 만들기 위한 httpServer 객체를 전달 받는다.
```java
// processRequest를 호출하는 클라이언트 코드
var httpserver = HttpServer.create(new InetSocketAddress(8080), 0);
routerNEtworkAdapter.processRequest(httpserver);
```
- REST 어댑터는 HTTP를 통해 유저 데이터를 전달 받고, 요청 파라미터를 파싱하여 부모 클래스인 RouterNetworkAdapter에 정의된 addNetworkToRouter를 호출하기 위해 파싱한 파라미터를 사용한다.
```java
router = this.addNetworkToRouter(params);
```
- 입력 포트를 트리거하기 위해 유저데이터를 적절한 파라미터로 변환하는 것은 입력 어댑터의 책임이다. 
```java
routerNetworkUseCase.addNetworkToRouter(routerId, network);
```
- 이 시점에 데이터는 프레임워크 헥사곤을 떠나 애플리케이션 헥사곤으로 향한다.


```java
//CLI 입력 어댑터
// 다시 기반 어댑터를 확장한다.
public class RouterNetworkCLIAdapter extends RouterNetworkAdapter {
  public RouterNetworkCLIAdapter(RouterNetworkUseCase routerNetworkUseCase){
    this.routerNetworkUseCase = routerNetworkUseCase;
  }
/** code omitted **/
}
```
- RouterNetworkUseCase 유스케이스 참조를 받고 초기화하기 위해 RouterNetworkCLIAdapter 생성자를 정의한다.
- REST 입력 어댑터에서는 H2를 사용했지만  CLI 입력 어댑터는 파일 시스템을 사용한다.
```java
RouterNetworkOutputPort outputPort = RouterNetworkFileAdapter.getInstance();
RouterNetworkUseCase usecase = new RouterNetworkInputPort(outputPort);
RouterManageNetworkAdapter inputAdapter = new RouterNetworkCLIAdapter(routerNetworkUseCase);
```
- 우선 RouterNetworkOutputPort 출력 포트의 참조를 얻고(RouterNetworkFileAdapter.getInstance();)
- 해당 참조를 사용해 RouterNetworkUseCase 유스케이스를 가져온 다음,
- 해당 유스케이스로 RouterNetworkAdapter를 얻는다.
```java
// CLI 어댑터의 processRequest 메서드 구현
@Override
public Router processRequest(Object requestParams){
    var params = stdinParams(requestParams);
    router = this.addNetworkToRouter(params);
    
    ObjectMapper mapper = new ObjectMapper();
    try {
        var routerJson = mapper.writeValueAsString(RouterJsonFileMapper.toJson(router));
        System.out.println(routerJson);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
    }
    
    return router;
}
```
- 예시 코드에는 생략 되었지만 REST 어댑터에는 HTTP 요청으로부터 데이터를 추출하기 위한 httpParams 메서드가 있는데 CLI 어댑터에서 비슷한 작업을 하는 stdinParams 메서드가 있다.
```java
private void httpParams(String query, Map<String, String> params) {
    var noNameText = "Anonymous";
    var requestParams = Pattern.compile("&")
        .splitAsStream(query)
        .map(s -> Arrays.copyOf(s.split("="), 2))
        .collect(groupingBy(s -> decode(s[0]), mapping(s -> decode(s[1]), toList())));
    
        var routerId = requestParams.getOrDefault("routerId", List.of(noNameText)).stream().findFirst().orElse(noNameText);
        params.put("routerId",routerId);
        
        var address = requestParams.getOrDefault("address", List.of(noNameText)).stream().findFirst().orElse(noNameText);
        params.put("address",address);
        
        var name = requestParams.getOrDefault("name", List.of(noNameText)).stream().findFirst().orElse(noNameText);
        params.put("name",name);
        
        var cidr = requestParams.getOrDefault("cidr", List.of(noNameText)).stream().findFirst().orElse(noNameText);
        params.put("cidr",cidr);
    }

    private static String decode(final String encoded) {
        try {
            return encoded == null ? null : URLDecoder.decode(encoded, "UTF-8");
        } catch (final UnsupportedEncodingException e) {
            throw new RuntimeException("UTF-8 is a required encoding", e);
        }
    }
```
```java
private Map<String, String> stdinParams(Object requestParams){
        Map<String, String> params = new HashMap<>();
        if(requestParams instanceof Scanner){
            var scanner = (Scanner) requestParams;
            
            System.out.println("Please inform the Router ID:");
            var routerId = scanner.nextLine();
            params.put("routerId", routerId);
            
            System.out.println("Please inform the IP address:");
            var address = scanner.nextLine();
            params.put("address", address);
            
            System.out.println("Please inform the Network Name:");
            var name = scanner.nextLine();
            params.put("name", name);
            
            System.out.println("Please inform the CIDR:");
            var cidr = scanner.nextLine();
            params.put("cidr", cidr);
        } else {
            throw new IllegalArgumentException("Request with invalid parameters");
        }
        
        return params;
    }
```
- REST 어댑터와 CLI 어댑터는 `입력 데이터 처리 방식`에는 차이가 있지만, 입력 데이터를 params로 변환한 이후 `두 어댑터 모두 addNetworkToRouter메서드를 호출`한다.
```java
router = this.addNetworkToRouter(params);
```

```java
// 입력 어댑터 호출
// 어느 어댑터를 선택할지 제어하는 클라이언트 코드
public class App {

  private RouterNetworkAdapter inputAdapter;
  private RouterNetworkUseCase usecase;
  private RouterNetworkOutputPort outputPort;

  public static void main(String... args)  {
    var adapter = "cli";
    if(args.length>0) {
      adapter = args[0];
    }
    new App().setAdapter(adapter);
  }

  void setAdapter(String adapter) { //switch-case 조건에 따라 인스턴스를 생성하고 호출한다.
    switch (adapter) {
      case "rest" -> {
        outputPort = RouterNetworkH2Adapter.getInstance();
        usecase = new RouterNetworkInputPort(outputPort);
        inputAdapter = new RouterNetworkRestAdapter(usecase);
        rest();
      }
      default -> {
        outputPort = RouterNetworkFileAdapter.getInstance();
        usecase = new RouterNetworkInputPort(outputPort);
        inputAdapter = new RouterNetworkCLIAdapter(usecase);
        cli();
      }
    }
  }

  private void cli() {
    Scanner scanner = new Scanner(System.in);
    inputAdapter.processRequest(scanner);
  }

  private void rest() {
    try {
      System.out.println("REST endpoint listening on port 8080...");
      var httpserver = HttpServer.create(new InetSocketAddress(8080), 0);
      inputAdapter.processRequest(httpserver);
    } catch (IOException e){
      e.printStackTrace();
    }
  }
}
```
1. 기반 입력 어댑터 정의
2. 기반 어댑터 확장

- 입력 어댑터는 헥사고날 애플리케이션이 제공할 수 있는 모든 기능에 엑세스할 수 있는 정문같은 것이다.
- 입력 어댑터를 통해 비즈니스 로직을 휘젓지 않고도 다양한 기술을 통해 시스템에 접근하도록 할 수 있다.
- 이와 동일한 방법으로 출력 어댑터를 사용해 다양한 데이터 소스와 통신하도록 할 수 있다.



## 다양한 데이터 소스와 통신을 위한 출력 어댑터 사용
- 시스템을 다양한 기술과 통합하는 것이 자연스러워지고 있다. 
- 이런 통합은 소프트웨어 개발에서 몇가지 어려움을 야기하는데, 이는 이종 기술적 맥락에서 시스템 스스로가 스스로를 이해하고, 이해할 수 있어야 하기 때문이다(?)
  - 아마 다양한 기술과 문제없이 통합되기 위해서는 각 시스템이 서로의 특징이나 규칙등을 이해해야 한다는 뜻이 아닐까?
    - 즉, 자기 자신도 다른 기술 혹은 시스템이 문제없이 사용할 수 있는 형태의 기능을 제공하고, 다른 기술 혹은 시스템이 제공하는 기능을 문제없이 사용할 수 있어야 한다.
### 출력 어댑터 생성
- 입력 어댑터와 함께 프레임워크 헥사곤을 구성하는 컴포넌트
- 드리븐 오퍼레이션을 처리한다.
  - 데이터를 보내거나 받기 위해 외부 시스템과 상호작용하는 헥사고날 애플리케이션에서 시작된 오퍼레이션
- 유스케이스 입력 토프 구현에 있는 오퍼레이션에 의해 트리거된다.
- 출력 포트는 외부 시스템과의 상호 작용을 추상적으로 표현
- 출력 어댑터는 상호 작용의 방법을 구체적으로 설명한다. 즉 외부 통합을 허용하기 위한 기술을 결정한다.
- 지금까지는 도메인 헥사곤에 생성한 도메인 모델이 표현하는 요구사항만으로 데이터에 관해 이야기 했다.
- 결국, 헥사고날 시스템의 형태를 유도하는 것은 도메인 헥사곤의 도메인 모델이고, 기술적 문제는 도메인 모델을 준수해야 하는 세부사항일 뿐이다.
- 출력 포트를 애플리케이션 헥사곤의 인터페이스로서 사용을 하고, 해당 인터페이스를 구현하는 출력 어댑터를 프레임워크 헥사곤에 만들어 사용함으로써 우리는 헥사고날 시스템이 여러가지 기술들을 지원하도록 만들 수 있다.
  - 이 구조에서 프레임워크 헥사곤은 애플리케이션 헥사곤의 인터페이스를 따라야 하며, 애플리케이션 헥사곤은 도메인 헥사곤에 있는 도메인 모델에 의지한다는 것을 알아야 한다.
![4_4.PNG](images%2F4_4.PNG)
  - 출력 어댑터의 UML
![4_5.PNG](images%2F4_5.PNG)
  - 재무 네트워크가 포함된 토폴로지 및 인벤토리 시스템

```sql
--H2 출력 어댑터
-- 토폴로지 및 인벤토리 시스템의 데이터베이스 구조 정의
CREATE TABLE routers(
                      router_id UUID PRIMARY KEY NOT NULL,
                      router_type VARCHAR(255)
);

CREATE TABLE switches (
                        switch_id UUID PRIMARY KEY NOT NULL,
                        router_id UUID,
                        switch_type VARCHAR(255),
                        switch_ip_protocol VARCHAR(255),
                        switch_ip_address VARCHAR(255),
                        PRIMARY KEY (switch_id),
                        FOREIGN KEY (router_id) REFERENCES routers(router_id)
);

CREATE TABLE networks (
                        network_id int NOT NULL PRIMARY KEY AUTO_INCREMENT,
                        switch_id UUID,
                        network_protocol VARCHAR(255),
                        network_address VARCHAR(255),
                        network_name VARCHAR(255),
                        network_cidr VARCHAR(255),
                        PRIMARY KEY (network_id),
                        FOREIGN KEY (switch_id) REFERENCES switches(switch_id)
);

INSERT INTO routers(router_id, router_type) 
VALUES('ca23800e-9b5a-11eb-a8b3-0242ac130003', 'EDGE');

INSERT INTO switches(switch_id, router_id, switch_type, switch_ip_protocol, switch_ip_address)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'ca23800e-9b5a-11eb-a8b3-0242ac130003', 'LAYER3', 'IPV4', '9.0.0.9');

INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '10.0.0.0', 'HR', '8');

INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '20.0.0.0', 'Marketing', '8');

INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '30.0.0.0', 'Engineering', '8');

```
- switches, networks 모두 기본키를 가지고 있지만, switches는 entitiy처럼, networks는 도메인 모델의 Router엔티티의 일부인 VO처럼 취급한다. 
  - 이는 모델에 기술적인 배치를 부과하는 것이다(?)
- router_id값을 사용해 Router를 애그리게잇 루트로, Switch와 Network를 애그리게잇 구성요소로 사용하는 애그리게잇의 형성을 가능하게 한다.

```java
public interface RouterNetworkOutputPort {
    Router fetchRouterById(RouterId routerId);

    boolean persistRouter(Router router);
}
```
```java
public class RouterNetworkH2Adapter implements RouterNetworkOutputPort {

    private static RouterNetworkH2Adapter instance;

    @PersistenceContext
    private EntityManager em;

    private RouterNetworkH2Adapter(){
        setUpH2Database();
    }

    @Override
    public Router fetchRouterById(RouterId routerId) {
        var routerData = em.getReference(RouterData.class, routerId.getUUID());
        return RouterH2Mapper.toDomain(routerData);
    }

    @Override
    public boolean persistRouter(Router router) {
        var routerData = RouterH2Mapper.toH2(router);
        em.persist(routerData);
        return true;
    }

    private void setUpH2Database() {
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("inventory");
        EntityManager em = entityManagerFactory.createEntityManager();
        this.em = em;
    }

    public static RouterNetworkH2Adapter getInstance() {
        if (instance == null) {
            instance = new RouterNetworkH2Adapter();
        }
        return instance;
    }
}
```
- fetchRouterById에서 Router 도메인 엔티티를 데이터베이스에 바로 매핑할 수 없고, 데이터베이스 엔티티를 도메인 엔티티로 사용할 수 없기 때문에 toDomain 메서드를 사용해 H2 데이터베이스에서 도메인으로 데이터를 매핑한다.
```java
public class RouterH2Mapper {

        public static Router toDomain(RouterData routerData){
            var routerType = RouterType.valueOf(routerData.getRouterType().name());
            var routerId = RouterId.withId(routerData.getRouterId().toString());
            var switchId = SwitchId.withId(routerData.getNetworkSwitch().getSwitchId().toString());
            var switchType = SwitchType.valueOf(routerData.getNetworkSwitch().getSwitchType().toString());
            var ip = IP.fromAddress(routerData.getNetworkSwitch().getIp().getAddress());
            var networks =  getNetworksFromData(routerData.getNetworkSwitch().getNetworks());

            var networkSwitch = new Switch(switchId, switchType,networks, ip);
            return new Router(routerType, routerId, networkSwitch);
        }


        public static RouterData toH2(Router router){
            var routerTypeData = RouterTypeData.valueOf(router.getRouterType().toString());
            var routerId = router.getRouterId().getUUID();
            var switchId = router.getNetworkSwitch().getSwitchId().getUUID();
            var switchTypeData = SwitchTypeData.valueOf(router.getNetworkSwitch().getSwitchType().toString());
            var ipData = IPData.fromAddress(router.getNetworkSwitch().getAddress().getIPAddress());
            var networkDataList = getNetworksFromDomain(router.retrieveNetworks(), routerId);

            var switchData = new SwitchData(
                    routerId,
                    switchId,
                    switchTypeData,
                    networkDataList,
                    ipData);
            return new RouterData(routerId, routerTypeData, switchData);
        }

        private static List<Network> getNetworksFromData(List<NetworkData> networkData){
            return networkData
                    .stream()
                    .map(network -> new Network(
                            IP.fromAddress(network.getIp().getAddress()),
                            network.getName(),
                            network.getCidr()))
                    .collect(Collectors.toList());
        }

        private static List<NetworkData> getNetworksFromDomain(List<Network> networks, UUID switchId){
            return  networks
                     .stream()
                     .map(network -> new NetworkData(
                            switchId,
                            IPData.fromAddress(network.getAddress().getIPAddress()),
                            network.getName(),
                            network.getCidr()))
                     .collect(Collectors.toList());
        }
}
```
- toH2 메서드를 사용하여 도메인에서 H2 데이터베이스로 변환하기 위해 동일한 매핑 절차를 거친다.
- setUpH2Database메서드는 애플리케이션이 시작 될 때 데이터베이스를 구동하는데, 단 하나의 H2 어댑터 인스턴스를 생성하기 위해 싱글턴을 사용한다.
```java
public static RouterNetworkH2Adapter getInstance() {
        if (instance == null) {
            instance = new RouterNetworkH2Adapter();
        }
        return instance;
    }
```
- instance 필드는 H2 출력 어댑터의 싱글턴 인스턴스를 제공하기 위해 사용된다.
- 생성자에서는 setUpH2Database메서드를 호출하여 EntityManager를 사용해 데이터베이스 커넥션을 가져온다.
- 이를 제대로 설정하기 위한 설정 파일을 만들어야 한다.
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!-- code omitted -->
<property
  name="jakarta.persistence.jdbc.url"
    value="jdbc:h2:mem:inventory;
    MODE=MYSQL;
    DB_CLOSE_DELAY=-1;
    DB_CLOSE_ON_EXIT=FALSE;
    IGNORECASE=TRUE;
    INIT=CREATE SCHEMA IF NOT EXISTS inventory\;
    RUNSCRIPT FROM 'classpath:inventory.sql'" />
<!-- code omitted -->

```
- 시스템과 데이터베이스 기술이 결합되면 안된다. 도메인 모델이 우선시 되야 하기 때문이다.(??)
  - 데이터베이스 타입에 직접 매핑하기 위해 RouterData ORM 클래스를 만들어야 하는 이유이다.
```java
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "routers")
@SecondaryTable(name = "switches")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass= UUIDTypeConverter.class)
public class RouterData implements Serializable {

    @Id
    @Column(name="router_id",
            columnDefinition = "uuid",
            updatable = false )
    @Convert("uuidConverter")
    private UUID routerId;

    @Embedded
    @Enumerated(EnumType.STRING)
    @Column(name="router_type")
    private RouterTypeData routerType;


    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(table = "switches",
            name = "router_id",
            referencedColumnName = "router_id")
    private SwitchData networkSwitch;
}
```
```java
// RouterData 클래스 상단의 @Converter 애노테이션 내부에서 사용하는 클래스.
public class UUIDTypeConverter implements Converter
{
    @Override
    public UUID convertObjectValueToDataValue(Object objectValue, Session session)
    {
        return (UUID) objectValue;
    }


    @Override
    public UUID convertDataValueToObjectValue(Object dataValue, Session session)
    {
        return (UUID) dataValue;
    }


    @Override
    public boolean isMutable()
    {
        return true;
    }


    @Override
    public void initialize(DatabaseMapping mapping, Session session)
    {
        DatabaseField field = mapping.getField();
        field.setSqlType(Types.OTHER);
        field.setTypeName("java.util.UUID");
        field.setColumnDefinition("UUID");
    }
}
```
```java
@Embeddable // Embedded 애노테이션을 통해 기반 클래스의 열거형 데이터를 router_type 필드에 매핑될 수 있게 한다.
public enum RouterTypeData {
    EDGE,
    CORE;
}
```
```java
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "switches")
@SecondaryTable(name = "networks")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass= UUIDTypeConverter.class)
public class SwitchData implements Serializable {

    @Id
    @Column(name="switch_id",
            columnDefinition = "uuid",
            updatable = false )
    @Convert("uuidConverter")
    private UUID switchId;

    @Column(name="router_id")
    @Convert("uuidConverter")
    private UUID routerId;

    @Enumerated(EnumType.STRING)
    @Embedded
    @Column(name = "switch_type")
    private SwitchTypeData switchType;

    @OneToMany
    @JoinColumn(table = "networks",
            name = "switch_id",
            referencedColumnName = "switch_id")
    private List<NetworkData> networks;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(
                    name = "address",
                    column = @Column(
                            name = "switch_ip_address")),
            @AttributeOverride(
                    name = "protocol",
                    column = @Column(
                            name = "switch_ip_protocol")),
    })
    private IPData ip;
}
```
```java
@Embeddable
public enum SwitchTypeData {
    LAYER2,
    LAYER3;
}
```


- 토폴로지 및 인벤토리 시스템에서는 스위치에 네트워크를 직접 연결한다. H2 데이터베이스 엔티티에 도메인 엔티티를 매핑하기 위해 NetworkData 클래스를 구현한다.
```java
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "networks")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass= UUIDTypeConverter.class)
public class NetworkData implements Serializable {

    @Id
    @Column(name="network_id")
    private int id;

    @Column(name="switch_id")
    @Convert("uuidConverter")
    private UUID switchId;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(
                    name = "address",
                    column = @Column(
                            name = "network_address")),
            @AttributeOverride(
                    name = "protocol",
                    column = @Column(
                            name = "network_protocol")),
    })
    IPData ip;

    @Column(name="network_name")
    String name;

    @Column(name="network_cidr")
    Integer cidr;

    public NetworkData(UUID switchId, IPData ip, String name, Integer cidr) {
        this.switchId = switchId;
        this.ip = ip;
        this.name = name;
        this.cidr = cidr;
    }
}
```


- SwitchData와 NetworkData 모두 IPData를 선언한다.
```java
@Embeddable
@Getter
public class IPData {

    private String address;

    @Enumerated(EnumType.STRING)
    @Embedded
    private ProtocolData protocol;

    private IPData(String address){
        if(address == null)
            throw new IllegalArgumentException("Null IP address");
        this.address = address;
        if(address.length()<=15) {
            this.protocol = ProtocolData.IPV4;
        } else {
            this.protocol = ProtocolData.IPV6;
        }
    }

    public IPData() {

    }

    public static IPData fromAddress(String address){
        return new IPData(address);
    }
}
```
```java
@Embeddable
public enum ProtocolData {
    IPV4,
    IPV6
}
```
- 어떻게 보면 이러한 클래스들을 만드는 것이 재사용성을 해치고 반복되는 작업이라 볼 수 있다. 
- 이는 애플리케이션이 다른 여러 기술들과 잘 통합할 수 있게 하며 발생하는 트레이드 오프다.
