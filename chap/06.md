# 도메인 헥사곤 만들기
## 도메인 헥사곤 생성
- 시스템의 기능 일부를 보강하고 자바 모듈에 도메인 헥사곤을 캡슐화 하기 위해 JPMS(Java Platform Module System)를 사용한다.
### JPMS
- JPMS 이전에는 보통 Java 플랫폼은 하나의 모놀리식으로 구성되었다.
### JPMS의 목표
1. Reliable configuration(신뢰적인 구성)
   - 모듈은 서로 의존 관계를 가질 수 있는데, 모듈 간의 의존성을 명시적으로 선언할 수 있는 매커니즘을 제공합니다. 
   - 이 매커니즘을 통해 모든 모듈 중에서 시스템에 필요한 모듈만을 고를 수 있습니다. 
   - 설정된 의존성은 컴파일 시와 런타임 시에 모두 인식됩니다.
2. Strong encapsulation(강력한 캡슐화)
   - 모듈 내에 있는 패키지를 다른 모듈이 접근할 수 없습니다. 
   - 모듈 configuration에서 명시적으로 export한 패키지에 대해서만 다른 모듈이 접근할 수 있습니다. 
   - 그리고 다른 모듈은 그 패키지를 명시적으로 사용한다고 선언해야 사용할 수 있습니다.
   - 모듈의 캡슐화는 잠재적인 공격자가 클래스에 접근하는 것을 막아주기 때문에 플랫폼의 보안을 향상시킵니다.
3. Scalable Java platform(확장 가능한 Java 플랫폼)
   - 이전에는 Java 플랫폼이 방대한 패키지들로 구성된 모놀리틱 플랫폼이었기 때문에, 시스템을 개발, 유지 보수, 발전시키는 데에 어려움이 있었습니다. 
   - 이제는 플랫폼이 여러 모듈로 모듈화되어 애플리케이션에 필요한 모듈들로만 런타임을 구성할 수 있습니다. 
   - 이를 통해 런타임의 크기를 줄일 수 있습니다.
4. Greater platform integrity(더 나은 플랫폼 무결성)
   - Java 9 이전에는 Java API 중에 사용하라는 의미가 아니었던 클래스들을  애플리케이션에서 사용할 수 있었습니다. 
   - 이제는 캡슐화를 통해 이런 내부 API들은 Java 플랫폼을 사용하는 애플리케이션에서는 숨겨지고 사용할 수 없습니다.
5. Improved performance(향상된 성능)
   - JVM은 애플리케이션의 성능 향상을 위해 다양한 최적화 기법을 사용합니다. 이런 기법들은 모듈 간의 의존성을 컴파일 단계에 미리 알고있을 때 더 효과적입니다.
- https://stackoverflow.com/questions/3680883/whats-the-difference-between-package-and-module
  - 모듈을 사용하면 몇 개의 패키지를 하나의 단일 논리 장치로 구성하고 이를 하나의 시스템으로 배포할 수 있습니다.
## 문제 영역 이해
- 시스템을 구축하는 방법
  - 먼저 도메인 모델을 이용, 최상위 수준에서 시스템의 목적 달성에 필요한 오퍼레이션과 규칙을 포함하는 도메인 헥사곤을 생성한다.
    - 가장 베스트는 다른 레이어들의 도움 없이 도메인 헥사곤에서 비즈니스 아이디어를 곧바로 검증하는 것.
    - 기술특화적이지 않도록 해야 한다.
  - 도메인 오퍼레이션을 검증하기 위한 단위 테스트 작성
  - 값 객체를 가지고 헥사고날 시스템의 기반 구축
- 결국 문제 영역 이해라는 것은 무엇을 해야 하는건가?
  - 유스케이스 작성?
  - 
## 값 객체 정의
- 엔티티 : 식별자를 갖고 있는 시스템 컴포넌트를 분류하는 데 사용하는 요소
- 값 객체는 식별자가 없다.
  - 식별자가 필요없는 시스템 요소를 기술할 때 사용한다.
- 객체의 관련 엔티티와 값들을 캡슐화 하는 애그리게잇이 있다.


- 더 정교한 값 객체와 가장 중요한 엔티티를 만들기 위한 기반이므로 먼저 값 객체를 생성한다.
- 값 객체 생성 예시
- 정교한 값 겍체 생성 예시
## 엔티티와 명세 정의
- 모든 값 객체를 생성한 뒤 엔티티 내의 요소를 표시하는 방법을 생각하고 엔티티가 준수하는 제약조건을 규정하는 비즈니스 규칙을 정의하기 위한 명세를 개발한다.
- 엔티티를 특정짓는 것은 식별자, 비즈니스 규칙, 그리고 데이터

### Equipment와 Router 추상 엔티티
```java
// Equipment 추상 클래스
@Getter
@AllArgsConstructor
public abstract class Equipment {
    protected Id id;
    protected Vendor vendor;
    protected Model model;
    protected IP ip;
    protected Location location;
    
    public static Predicate<Equipment> getVendorPredicate(Vendor vendor) { //특정 공급업체의 장비만 검색하는 필터
        return r -> r.getVendor().equals(vendor);
    }
    
}
```

```java
// Equipment에서 파생되는 Router 추상 클래스
@Getter
public abstract class Router extends Equipment{
    
    protected final RouterType routerType;
    
    public static Predicate<Router> getRouterTypePredicate(RouterType routerType) { //특정 유형의 라우터만 검색하는 필터
        return r -> r.getRouterType().equals(routerType);
    }
    
    /** 코드생략 **/
}
```

```java
// Router 추상 클래스에서 나온 두 개의 추가적인 프레디케이트
public static Predicate<Equipment> getRouterTypePredicate(Model model) { //특정 모델의 라우터만 검색하는 필터
  return r -> r.getModel().equals(model);
}

public static Predicate<Equipment> getRouterTypePredicate(Location location) { //특정 모델의 라우터만 검색하는 필터
  return p -> p.location.getCountry().equals(location.getCountry);
}
```

- Router 추상 클래스는 코어 라우터와 에지 라우터가 공유하는 공통적인 속성을 제공한다.
  - 라우터 리스트 조회시 필터 역할을 하는 프레디케이트를 도입하는 Router클래스 내에 있다.


### 코어 라우터 엔티티와 명세
```java
public class CoreRouter extends Router{
    /**코드생략**/
    
    public Router addRouter(Router anyRouter) {
        var sameCountryRouterSpec = new SameCountrySpec(this);
        var sameIpSpec = new SameIpSpec(this);
        
        sameCountryRouterSpec.check(anyRouter);
        sameIpSpec.check(anyRouter);
        
        return this.routers.put(anyRouter.id, anyRouter);
    }
    
    /** 코드생략 **/
}
```
- 코어 라우터가 다른 코어 라우터나 에지 라우터에 연결되는 동작을 CoreRouter에서 허용해야 한다.
  - 파라미터로 Router 추상 클래스 타입을 받는 addRouter 메서드를 만든다.
  - 같은 국가 안에 있는지 확인하는 SameCountry 명세도 사용한다.
  - 라우터가 IP 주소를 갖고 있는지 확인하는 명세가 있다.
- 이러한 명세들은 비즈니스 규칙을 명시적으로 만들고 읽기 쉽고 이해하기 쉬운 코드를 만든다.
  - if-else는 코드에 익숙하지 않은 사람에겐 부담이 될 수 있다.

- 생성한 엔티티들을 기반으로 해당 엔티티들과 직접 관련이 없는 작업에 대해 생각할 수 있다.
  - 도메인 엔티티 외부에서 기능을 제공하기 위한 대안으로 동작하는 서비스가 그러한 경우

## 도메인 서비스 정의
- 도메인 서비스를 통해 시스템 엔티티와 값 객체를 처리하기 위한 동작을 정의할 수 있다.
- 엔티티에 더 많은 동작을 직접 집어넣는 대신, 본질적으로 엔티티에 속하지 않는 동작을 가능하게 하는 별도의 서비스 클래스를 생성.


- 값 객체, 엔티티, 명세, 서비스 개발을 위해 TDD를 도입할 수 있다.
  - 실패한 테스트로 시작해 테스트를 통과할 수 있도록 클래스와 메서드를 구현하는 것.
- 생성한 오퍼레이션들이 예상대로 동작하는지 확인하지 않으면 업스트림 헥사곤이 망가지게 된다.

## 도메인 헥사곤 테스트
- 다른 헥사곤에서 들어오는 것은 무시하고 도메인 헥사곤의 컴포넌트에만 의존해야 한다.
  - 즉 다른 헥사곤들이 도메인 헥사곤에 의존해야 한다.
- 도메인 헥사곤은 핵심 시스템 로직에 집중
  - 이 핵심 시스템 로직으로부터 애플리케이션 헥사곤과 프레임워크 헥사곤의 구조와 행위를 도출한다.
- 견고하고 잘 테스트된 도메인 헥사곤을 만들면 전체 시스템의 견고한 기반을 만들 수 있다.
























































































