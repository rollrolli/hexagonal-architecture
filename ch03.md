## 03 포트와 유스케이스를 통한 동작 처리

### 유스케이스를 통한 소프트웨어 동작 표현
소프트웨어 시스템은  
사용자나 다른 소프트웨어 시스템이 정의한 목표를 달성하기 위해 함께 동작하는 일련의 행위 집합이다.

유스케이스는 SuD(System under Discussion) 행위의 상세한 글로 작성된 디스크립션을 제공하는 심층 분석을 수행한다.   
유스케이스는 SuD의 목표, 목표를 충족하기 위한 수단이나 행위, 가능한 실패 시나리오와 이들이 발생하는 경우에 수행해야 할 작업을 설정하는 귀중한 기법이다.

유스케이스 작성법
- 형식을 갖춘 유스케이스
    - 액터(Actor) : 인프라 엔지니어 
    - 목표(Goal): 에지 라우터에 새로운 네트워크를 추가
    - 범위(Scope): 인프라 부서
    - 트리거(Trigger): 다른 네트워크를 통한 네트워크 엑세스를 분리하는 특별한 이유
    - 입력 데이터(Input data): 라우터 ID, 네트워크 이름, 주소, CIDR

- 덜 형식적적이면서 간편한 타입
    - 액션(Actions)
    1.  라우터 ID를 찾는다.
    2. 네트워크 주소가 이미 존재하는지 확인한다.
    3. CIDR이 최솟값 아래인지 확인한다.
    4. 이전 검사에서 문제가 없다면 통보된 라우터에 네트워크를 추가한다.

행위 주도 설계(BDD: Behavior Driven Design) 방식
```
@addNetworkToRouter
Feature: 라우터에 네트워크 추가한다
기존 라우터에 네트워크를 추가하길 원한다.
Scenario: 기존 라우터에 네트워크 추가
    Given 라우터 ID와 네트워크 세부 사항을 제공한다.
    When 라우터를 발견햇다.
    And 네트워크 주소가 유요하며 기존에 존재하지 않는다.
    And CIDR 유효하다.
    Then 라우터에 네트워크 추가한다.
```
기능 파일에서 Given, When, And, Then 용어가 제공하는 단계를 기반으로  
유스케이스 단계의 유효성 검사를 자동화하는 클래스를 작성한다.

완전한 형식을 갖춘 유스케이스, 간단한 유스케이스, BDD 기반의 유스케이스는 모든 같은 것을 표현한다.  
주된 치이점은 대상(what)에 있지 않고 시스템 행위를 설명한다는 동일한 목적을 달성하는 방법(how)에 있다.

이 유스케이스 생성/처리를 건너뛰고 코드작업으로 넘어 갈수 있지만  
유스케이스의 예상 행위를 기록하고 구조화 해서 유스케이스의 처리 방식에 대한 아이디어를 명확히 하고 더 잘 조직화하는 것이 좋다.   

핵사고날 애플리케이션을 개발할 때 제안하는 바는 유스케이스를 구현보다는  
추상적 개념(인터페이스나 추상클래스를 사용)으로 설계하는 것이다.  



유스케이스를 인터페이스로 정의하는 이유
- 유스케이스 목표를 달성하는 다양한 방법 제공
- 구현보다는 추상적 개념에 대한 의존성 허용

### 입력 포트를 갖는 유스케이스 구현
드라이븡 액터는 애플리케이션에 요청을 보내는 사람이며, 드리븐 액터는 애플리케이션에서 액세스하는 외부 컴포넌트를 나타낸다. 드라이빙 액터와 드라이빙 오퍼레이션 사이의 통신 흐름을 허용하기 위해 입력 포트를 사용한다.

입력 포트 구현을 통해 유스케이스 목표를 만족시키기 위해 소프트웨어가 수행해야 하는 동작에 대한 명확한 뷰를 갖게 된다.

```
public class RouterNetworkInputPort implements RouterNetworkUseCase {

    private final RouterNetworkOutputPort routerNetworkOutputPort;

    public RouterNetworkInputPort(RouterNetworkOutputPort routerNetworkOutputPort){
        this.routerNetworkOutputPort = routerNetworkOutputPort;
    }

    @Override
    public Router addNetworkToRouter(RouterId routerId, Network network) {
        var router = fetchRouter(routerId);
        return createNetwork(router, network);
    }

    private Router fetchRouter(RouterId routerId) {
        return routerNetworkOutputPort.fetchRouterById(routerId);
    }

    private Router createNetwork(Router router, Network network) {
        var newRouter = NetworkOperation.createNewNetwork(router, network);
        return persistNetwork(router) ? newRouter :
                router;
    }

    private boolean persistNetwork(Router router) {
        return routerNetworkOutputPort.persistRouter(router);
    }
}

```

Router 객체를 반환하는 addNetworkToRouter 메서드는 입력 포트에 의해 노출되는 유일한 퍼블릭 메서드이다. 다른 모든 메서드는 이 입력 포트의 컨텍스트 외부에서 사용되서는 안되므로 프라이빗으로 만든다. 입력포트는 오직 RouterId로 Router 객체를 조회함으로써 작업을 시작한다.


입력 포트는 문제 영역에 대한 어떤 특정 항목도 포함되어 있지 않다.
주된 관심사는 도메인 서비스를 통한 내부 호출과 외부 포트를 통한 외부 호출을 조정하고 데이터를 처리하는 것이다. 입력포트는 오퍼레이션의 실행 순서를 설정하고 도메인 헥사곤인 이해할 수 있는 형식으로 데이터를 제공한다.

### 출력 포트를 이용한 외부 데이터 처리
출력 포트는 외부 데이터를 처리하려는 애플리케이션의 의도를 나타낸다.   
출력 포트를 통해 시스템이 외부 세계와 통신할 수 있도록 준비한다.

데이터베이스에서 지속성과 관련된 애플리케이션의 행위를 설명하게 위해 리포지토리나 데이터 접근 객체(DAO: Data Access Objects)는 출력포트로 대체된다.

출력 포트의 주된 목표는 데이터를 가져오는 방법을 지정하지 않고 어떤 종류의 데이터가 필요한지 지정하는 것이다.  
이것이 구현이 아닌 인터페이스를 정의하는 이유이다.   
출력포트 - SQL 어댑터, REST 어댑터, 파일 어댑터

### 애플리케이션 헥사곤을 통한 동작 자동화
자동화(Automation)는 소프트웨어가 할 수 있는 가장 가치 있는 일 중 하나다.

입력 포트를 통해 유스케이스 목표를 이루기 위해 비즈니스 규칙과 필요한 모든 데이터, 소비 처리,   
(필요한 경우) 출력 포트를 통한 외부 시스템에 대한 처리를 할 수 있다. 이러한 모든 활동을 종합하면 시스템의 의도를 만족시키기 위해 이러한 활동을 자동화하는 애플리케이션 헥사곤의 기본적인 역할이 분명해진다.

애플리케이션 헥사곤을 구현하는 한 가지 이점은   
시스템의 요구사항을 만족시키기 위해 사용해야 하는 기술을 지정할 필요가 없다는 점이다.