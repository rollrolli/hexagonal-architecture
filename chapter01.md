# 01 왜 헥사고날 아키텍처인가?

## 소프트웨어 아키텍처 검토

### 보이지 않는 것들
#### 기술 부채
* 크러프트(cruft): 소프트웨어 코드 내에 존재하는 불필요한 복잡성
### 악순환
* 기술 부채를 통제하지 못하면 애플리케이션을 포기해야 하는 상황이 온다.
### 아키텍처는 모두를 위한 것이 아니다
* 소프트웨어 아키텍처에 대한 기술팀과 경영진 모두의 이해가 필요하다.
### 모놀리식 시스템과 분산 시스템
* 과거에는 고가의 컴퓨팅 리소스와 네트워크 대역폭 때문에, 많은 책임을 단일 소프트웨어 단위로 그룹화하는 경향이 있었다.
* 소프트웨어의 규모가 너무 크면 로컬 실행 환경과 테스트가 어려워지고, CI 파이프라인, devops 피드백 루프를 손상시킨다.
* SOA(Service Oriented Architecture), MSA(MicroService Architecture)의 등장
* 헥사고날 아키텍처는 모놀리식 시스템과 분산 시스템 모두에 적용할 수 있다.
  * 모놀리식 시스템에서는 프론트엔드와 데이터베이스를 시스템과 분리하여, 그 두 가지가 없이도 테스트가 가능한, 변경에 더 강한 시스템을 개발할 수 있게 해준다.
  * 분산 시스템에서는 헥사고날 아키텍처가 가진 포트와 어댑터의 특성으로 인해 계속되는 기술의 변화를 소프트웨어가 처리할 수 있기 때문에 도움이 된다.
### 의사결정
* 헥사고날 아키텍처는 변경에 강한 애플리케이션을 만들 수 있게 해주어 의사결정이 계속 변하는 상황에서 유리하다.

## 헥사고날 아키텍처 이해
* 비즈니스 코드를 기술 코드로부터 분리한다.
  * 기술 측면이 비즈니스 측면에 의존하는지 확인하고, 사용되는 기술과 상관 없이 비즈니스 목표 달성이 가능해야 한다.
  * 기술 코드에 대한 변경을 할 때 관련된 비즈니스 코드에는 영향이 없어야 한다.
  * 이와 같은 목표를 위해, 비즈니스 코드가 기술 문제로부터 격리되고 보호될 적절한 위치를 결정해야 한다. => 이것이 `도메인 헥사곤`이다.
* 도메인 헥사곤(Domain hexagon)
  * 주된 요소: `엔티티(entity)`, `값 객체(value object)`
  * 엔티티: 식별자를 할당할 수 있는 것
  * 값 객체: 엔티티들을 합성하기 위해 사용하는 불변 컴포넌트
* 애플리케이션 헥사곤(Application hexagon)
  * 도메인 헥사곤에서 나오는 비즈니스 규칙을 사용, 처리하고 조정한다.
  * 비즈니스 측면과 기술 측면 사이에 있으며, 양쪽과 상호작용하는 중개자 역할을 한다.
  * `포트`와 `유스케이스`로 이루어져 있다.
* 프레임워크 헥사곤(Framework hexagon)
  * 외부 인터페이스를 제공한다.
  * 애플리케이션 기능의 노출 방법을 결정할 수 있는 곳이다.
  * 예: REST 나 gRPC 엔드포인트를 정의한다. 데이터베이스, 메시지 브로커 등에서 데이터를 가져오는 메커니즘을 정의한다.
  * `어댑터`를 통해 기술 결정을 구체화 한다.
---
### 도메인 헥사곤
* 실 세계 문제를 이해하고 모델링하는 활동
* 예시로 통신 회사에서 네트워크 및 토폴로지 인벤토리를 생성하는 프로젝트를 든다.
* 프로젝트를 진행할 때 도메인 지식은 가능한 한 기술에 구애받지 않는 형태로 표현해야 한다. 
* 비즈니스를 알지 못하는 상태로 프로젝트를 진행하면 중요한 작업을 놓칠 수 있다. 따라서 도메인 전문가나 해당 도메인 문제를 이미 알고 있는 개발자에게 조언을 구해야 한다. 
* 실제 문제에 대한 모델을 나타내는 `엔티티`가 모델링하고 있는 문제를 일관되게 반영하려면 계속 진화해야 한다.
* 문제 영역을 엔티티, 값 객체와 같은 다른 도메인 객체로의 변환 방법을 파악하지 못하면 잘못된 소프트웨어가 된다.
* 도메인 헥사곤은 문제 영역 표현을 위해 `엔티티(Entity)`와 `값 객체(Value Object)`로 이루어진다.

#### 엔티티
* 객체를 특징짓는 두 가지 - 연속성, 정체성
* 연속성
  * 객체의 수명주기 및 변경 가능한 특성과 연관이 있다.
  * 예시: 네트워크 및 토폴로지 인벤토리 시나리오의 라우터
    * 라우터의 활성 상태 / 비활성 상태 정의 가능
    * 라우터가 다른 라우터나 네트워크 장비와 갖는 관계는 시간이 지나면서 변할 수 있으므로 수명주기를 가진다고 말할 수 있음
* 정체성
  * 예시: 네트워크 및 토폴로지 인벤토리 시나리오의 라우터
    * 모든 라우터는 인벤토리에서 고유해야 하므로 식별자를 가져야 한다.
#### 값 객체
* 무언가 고유하게 식별할 필요가 없는 경우와 객체의 정체성보다 속성에 관심을 갖는 경우에 사용한다.
* 값 객체를 사용해 엔티티 객체를 구성할 수 있다.
* 예시: 라우터의 타입 - enum 으로 EDGE, CORE 두 종류는 나타낼 수 있다.

### 애플리케이션 헥사곤
* 애플리케이션 특화 작업을 추상적으로 처리하는 곳
* 도메인 비즈니스 규칙에 기반한 소프트웨어 사용자의 의도와 기능을 표현한다.
* 예시: 네트워크 토폴로지 인벤토리 시나리오에서 같은 타입의 라우터들을 조회하는 방법
  * 라우터 타입을 조회하기 위한 사용자 입력을 받아야 한다.
  * 사용자 입력을 검증하기 위해 특정 비즈니스 규칙을 사용해야 할 수도 있다.
  * 외부 소스에서 가져온 데이터를 검증하기 위해 또 다른 비즈니스 규칙을 사용해야 할 수도 있다.
  * 이러한 작업은 유스케이스에서 그룹화할 수 있다.

#### 유스케이스
* 유스케이스는 도메인 제약사항을 지원하기 위해 시스템의 동작을 소프트웨어 영역 내에 존재하는 애플리케이션 특화 오퍼레이션을 통해 나타낸다.
* 유스케이스는 엔티티 및 다른 유스케이스와 직접 상호작용하고 그것을 유연한 컴포넌트로 만들 수 있다.
* 자바에서 유스케이스는 소프트웨어가 할 수 있는 것을 표현하는 `인터페이스`로 추상화를 정의한다.
#### 입력 포트
* 유스케이스 인터페이스의 구현
* 유스케이스에 직접 연결되는 컴포넌트이므로 도메인 용어로 소프트웨어의 의도를 나타내야 한다.
* 예시: 조회하고자 하는 라우터를 필터링하는 방법
  * 입력 포트의 구현에서는 (출력 포트로) 애플리케이션 외부에서 라우터의 리스트를 가져올 수도 있다.
#### 출력 포트
* 유스케이스가 목표를 달성하기 위해 외부 리소스에서 데이터를 가져온다.
* 출력 포트: 유스케이스나 입력 포트가 오퍼레이션을 수행하기 위해 어떤 종류의 데이터를 외부에서 가져와야 하는지를 기술에 구애받지 않고 설명하는 `인터페이스`

### 프레임워크 헥사곤
* 소프트웨어와 통신하는 방식 두 가지 - 드라이빙(driving) 방식 / 드리븐(driven) 방식
  * 드라이빙 방식 -> `입력 어댑터(Input Adapter)` 사용
  * 드리븐 방식 -> `출력 어댑터(Output Adapter)` 사용
#### 드라이빙 오퍼레이션과 입력 어댑터
* 드라이빙 오퍼레이션: 소프트웨어에 동작을 요청하는 것
* 예시: 명령줄 클라이언트를 갖는 사용자, 프론트엔드 애플리케이션
* 소프트웨어에 의해 노축된 항목들의 정확성을 검사하는 일부 테스트 스위트가 있을 수 있다. 또는 노출된 일부 소프트웨어 기능과 상호작용이 필요한 대규모 생태계 내의 다른 애플리케이션일 수도 있다.
* 입력 어댑터 상단에 구축된 `애플리케이션 프로그래밍 인터페이스(API)`를 통해 이러한 통신이 일어난다.
* API는 외부 엔티티가 시스템과 상호작용하고, 외부 엔티티의 요청을 도메인 애플리케이션으로 변환하는 방법을 정의한다.
* 외부 엔티티들이 시스템의 동작을 유도(driving)하기 떄문에 드라이빙 오퍼레이션이라 부른다.
* 예시: HTTP/1.1 상의 SOAP 와 HTTP/2 상의 gRPC 를 통해 같은 기능을 노출해야 한다고 가정하자.
  * 헥사고날 아키텍처를 통해 두 시나리오 모두에 대한 `입력 어댑터`를 생성한다.
  * 도메인 관점에서 각 어댑터를 같은 입력 포트에 연결해 차례로 작동하도록 요청 다운스트림을 변환할 수 있다.
* 예제: STDIN 에서 데이터를 가져오는 입력 어댑터
  * REST 같은 다른 통신 형식을 활성화 하려면 새로운 입력 어댑터를 생성하면 된다.
#### 드리븐 오퍼레이션과 출력 어댑터
* 드리븐 오퍼레이션: 애플리케이션에서 트리거되고, 외부에서 소프트웨어 요구사항을 충족시키는 데 필요한 데이터를 가져온다.
* 일반적으로 드리븐 오퍼레이션은 일부 드라이빙 오퍼레이션에 응답해 발생한다.
* `출력 어댑터`를 통해서 드리븐 오퍼레이터를 정의한다. 이 어댑터들은 그것을 구현하는 `출력 포트`와 일치해야 한다.
* `출력 포트`는 일부 애플리케이션 특화 작업을 수행하는 데 필요한 데이터를 종류를 알려주고, `출력 어댑터`는 데이터를 어떻게 가져올지를 설명한다.
* 예시: 오라클 RDB 를 사용하다가 MongoDB 를 사용하기로 한 애플리케이션
  * 처음에는 오라클 DB 와의 출력 어댑터만 가지고 있었다.
  * MongoDB 와의 통신을 위해 프레임워크 헥사곤의 출력 어댑터를 생성해야 한다.
  * 입력 어댑터와 출력 어댑터 모두 헥사곤 내부를 가리키고 있기 때문에 이것들을 애플리케이션 및 도메인 헥사곤에 종속되게 만들어 의존성을 역전시킨다. (?)
* 헥사고날 애플리케이션 자체에 의해 이러한 오퍼레이션이 유도되고 통제되며, 다른 외부 시스템에서 동작을 트리거하기 때문에 드리븐(driven) 오퍼레이션이라 부른다.

---
### 헥사고날 접근 방식의 장점
* 헥사고날 아키텍처를 조직이 소프트웨어를 구성하는 기본 원칙을 수립하는 데 도움이 된다.
* 프로젝트를 전환할 때마다 개발자는 이전 프로젝트에서 획득한 헥사고날 원칙에 대해 이미 알고 있어 소프트웨어의 구조 파악에 대한 학습 곡선이 완만해진다.
#### 변경 허용(Change-tolerant)
* 헥사고날 아키텍처의 포트와 어댑터는 기술 변화에 용이하다.
#### 유지보수성(Maintainability)
* 비즈니스와 기술에 대한 관심사의 분리는 변경이 필요할 때 소프트웨어 구조 파악에 드는 노력을 줄여준다.
#### 테스트 용이성(Testability)
* UI 와 데이터베이스 같은 외부 의존성 없이 테스트가 가능하다.

## 요약
